# -*- coding: utf-8 -*-
"""Untitled1-Copy1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S0CglGVN_jlJhe-hoapJDTMYj367ob9L

# Import the libraries
"""

import numpy as np
import pandas as pd
from IPython.display import display, HTML
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import plotly.io as pio
import seaborn as sns
from importlib import reload
import matplotlib.pyplot as plt
import hvplot.pandas
import matplotlib
import warnings
from pandas.plotting import parallel_coordinates
import plotly.express as px
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Input, Dense, Activation, Dropout
from tensorflow.keras.optimizers import Adam
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.linear_model import BayesianRidge
from sklearn.metrics import mean_squared_error, r2_score, confusion_matrix, accuracy_score

"""# Give names to the features"""

index_names = ['engine', 'cycle']
setting_names = ['setting_1', 'setting_2', 'setting_3']
sensor_names=[ "(Fan inlet temperature) (◦R)",
"(LPC outlet temperature) (◦R)",
"(HPC outlet temperature) (◦R)",
"(LPT outlet temperature) (◦R)",
"(Fan inlet Pressure) (psia)",
"(bypass-duct pressure) (psia)",
"(HPC outlet pressure) (psia)",
"(Physical fan speed) (rpm)",
"(Physical core speed) (rpm)",
"(Engine pressure ratio(P50/P2)",
"(HPC outlet Static pressure) (psia)",
"(Ratio of fuel flow to Ps30) (pps/psia)",
"(Corrected fan speed) (rpm)",
"(Corrected core speed) (rpm)",
"(Bypass Ratio) ",
"(Burner fuel-air ratio)",
"(Bleed Enthalpy)",
"(Required fan speed)",
"(Required fan conversion speed)",
"(High-pressure turbines Cool air flow)",
"(Low-pressure turbines Cool air flow)" ]
col_names = index_names + setting_names + sensor_names

"""# Importing Datasets"""

Turbo_train = pd.read_csv(('train_FD002.txt'), sep='\s+', header=None, names=col_names)
Turbo_test = pd.read_csv(('test_FD002.txt'), sep='\s+', header=None, names=col_names)
Turbo_test_RUL = pd.read_csv(('RUL_FD002.txt'), sep='\s+', header=None, names=['RUL'])

"""# EDA on the dataset"""

Turbo_train.head()

Turbo_test.head()

Turbo_test_RUL.head()

Turbo_train.info()

Turbo_train.describe()

# Create a violin plot
sns.violinplot(x='engine', y='(Fan inlet Pressure) (psia)', data=Turbo_train, palette='husl')
plt.title('Violin Plot of Fan Inlet Temperature by Engine')
plt.show()

# Create a parallel coordinates plot
parallel_coordinates(Turbo_train[sensor_names + ['engine']], 'engine', colormap='viridis')
plt.title('Parallel Coordinates Plot of Sensor Features by Engine')
plt.show()

# Compute value counts of a categorical feature
counts = Turbo_train['engine'].value_counts()

# Create a bar chart of value counts
fig, ax = plt.subplots()
ax.bar(counts.index, counts.values, color=plt.cm.viridis(np.arange(len(counts))))
ax.set_xlabel('Engine')
ax.set_ylabel('Count')
ax.set_title('Bar Chart of Engine Counts')

# Create a scatter plot of two numerical features
fig = px.scatter(Turbo_train, x='(Fan inlet temperature) (◦R)', y='(Fan inlet Pressure) (psia)', color='engine', size='setting_1',
                 hover_name='cycle', title='Scatter Plot of Fan Inlet Temperature vs Fan Inlet Pressure')
fig.show()

# Create a treemap of a categorical feature
fig = px.treemap(Turbo_train, path=['engine'], values='setting_1', color='(Fan inlet temperature) (◦R)',
                 hover_name='cycle', title='Treemap of Engine with Fan Inlet Temperature as Color')
fig.show()

# Compute correlations
corr = Turbo_train.corr()

# Create correlation plot
sns.set(style='white')
mask = np.triu(np.ones_like(corr, dtype=bool))
cmap = sns.diverging_palette(240, 10, as_cmap=True)
plt.figure(figsize=(12, 10))
sns.heatmap(corr, mask=mask, cmap=cmap, annot=True, fmt=".2f", linewidths=0.5, cbar_kws={'shrink': 0.8})
plt.title('Correlation Plot of Features in Turbo_train Dataset')
plt.show()

Selected_Features = []
import statsmodels.api as sm

def backward_regression(X, y, initial_list=[], threshold_out=0.05, verbose=True):
    included = list(X.columns)
    while True:
        changed = False
        model = sm.OLS(y, sm.add_constant(pd.DataFrame(X[included]))).fit()
        # use all coefs except intercept
        pvalues = model.pvalues.iloc[1:]
        worst_pval = pvalues.max()  # null if pvalues is empty
        if worst_pval > threshold_out:
            changed = True
            worst_feature = pvalues.idxmax()
            included.remove(worst_feature)
            if verbose:
                print(f"worst_feature : {worst_feature}, {worst_pval} ")
        if not changed:
            break
    Selected_Features.append(included)
    print(f"\nSelected Features:\n{Selected_Features[0]}")

X = Turbo_train.iloc[:,1:-1]
y = Turbo_train.iloc[:,-1]
backward_regression(X, y)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""# Support Vector Machine (SVM) Regression"""

# Replace the kernel, C, and epsilon parameters as per your requirement
svm_reg = SVR(kernel='rbf', C=1.0, epsilon=0.1)
svm_reg.fit(X_train, y_train)
svm_pred = svm_reg.predict(X_test)

# Compute Mean Squared Error (MSE), R2 for Support Vector Machine (SVM) Regression
mse_svm = mean_squared_error(y_test, svm_pred)
r2_svm = r2_score(y_test, svm_pred)

print("Mean Squared Error (MSE) for SVM Regression: ", mse_svm)
print("R2 Score for SVM Regression: ", r2_svm)

pd.DataFrame({'True Values': y_test, 'Predicted Values': svm_pred}).plot.scatter(x='True Values', y='Predicted Values')

pd.DataFrame({'Error Values': (y_test - svm_pred)}).plot.kde()

"""#  K-Nearest Neighbors (KNN) Regression"""

# Replace the n_neighbors and weights parameters as per your requirement
knn_reg = KNeighborsRegressor(n_neighbors=5, weights='distance')
knn_reg.fit(X_train, y_train)
knn_pred = knn_reg.predict(X_test)

# Compute Mean Squared Error (MSE), R2 for K-Nearest Neighbors (KNN) Regression
mse_knn = mean_squared_error(y_test, knn_pred)
r2_knn = r2_score(y_test, knn_pred)

print("Mean Squared Error (MSE) for KNN Regression: ", mse_knn)
print("R2 Score for KNN Regression: ", r2_knn)

pd.DataFrame({'True Values': y_test, 'Predicted Values': knn_pred}).plot.scatter(x='True Values', y='Predicted Values')

pd.DataFrame({'Error Values': (y_test - knn_pred)}).plot.kde()

"""#  Bayesian Models"""

# Instantiate and fit Bayesian Ridge regression model
bayesian_reg = BayesianRidge()
bayesian_reg.fit(X_train, y_train)
# Predict on test data
bayesian_pred = bayesian_reg.predict(X_test)
# Calculate metrics
mse = mean_squared_error(y_test, bayesian_pred)
r2 = r2_score(y_test, bayesian_pred)

print("Bayesian Ridge Regression:")
print("Mean Squared Error: ", mse)
print("R2 Score: ", r2)

pd.DataFrame({'True Values': y_test, 'Predicted Values': bayesian_pred}).plot.scatter(x='True Values', y='Predicted Values')

pd.DataFrame({'Error Values': (y_test - bayesian_pred)}).plot.kde()

"""#Artificial Neural Network (ANN) Regression"""

X_train = np.array(X_train)
X_test = np.array(X_test)
y_train = np.array(y_train)
y_test = np.array(y_test)

model = Sequential()
model.add(Dense(X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
# model.add(Dropout(0.2))
model.add(Dense(64, activation='relu'))
# model.add(Dropout(0.2))
model.add(Dense(128, activation='relu'))
# model.add(Dropout(0.2))
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.1))
model.add(Dense(1))
model.compile(optimizer=Adam(0.00001), loss='mse')

r = model.fit(X_train, y_train,
              validation_data=(X_test,y_test),
              batch_size=400,
              epochs=20)

pd.DataFrame(r.history)

pd.DataFrame(r.history).plot.line(y=['loss', 'val_loss'])

from sklearn import metrics
from sklearn.model_selection import cross_val_score

def cross_val(model):
    pred = cross_val_score(model, X, y, cv=10)
    return pred.mean()

def print_evaluate(true, predicted):  
    mae = metrics.mean_absolute_error(true, predicted)
    mse = metrics.mean_squared_error(true, predicted)
    rmse = np.sqrt(metrics.mean_squared_error(true, predicted))
    r2_square = metrics.r2_score(true, predicted)
    print('MAE:', mae)
    print('MSE:', mse)
    print('RMSE:', rmse)
    print('R2 Square', r2_square)
    print('__________________________________')
    
def evaluate(true, predicted):
    mae = metrics.mean_absolute_error(true, predicted)
    mse = metrics.mean_squared_error(true, predicted)
    rmse = np.sqrt(metrics.mean_squared_error(true, predicted))
    r2_square = metrics.r2_score(true, predicted)
    return mae, mse, rmse, r2_square

test_pred = model.predict(X_test)
train_pred = model.predict(X_train)

print('Test set evaluation:\n_____________________________________')
print_evaluate(y_test, test_pred)

print('Train set evaluation:\n_____________________________________')
print_evaluate(y_train, train_pred)

results_df_2 = pd.DataFrame(data=[["Artficial Neural Network", *evaluate(y_test, test_pred), 0]], 
                            columns=['Model', 'MAE', 'MSE', 'RMSE', 'R2 Square', 'Cross Validation'])